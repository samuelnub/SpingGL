#pragma once
#ifndef TOOLS_GENERATORS_GALAXYGEN_H
#define TOOLS_GENERATORS_GALAXYGEN_H

#include <vector>
#include <cmath>
#include <random>
#include <map>

#include <glm\glm.hpp>
#include <glm\gtc\matrix_transform.hpp>
#include <glm\gtc\type_ptr.hpp>

#include <tools/meshes.h>

//credit due to https://github.com/martindevans/CasualGodComplex

enum class GalaxyType
{
	ELLIPTICAL,
	IRREGULAR,
	SPIRAL,

	ENUM_SIZE
};

enum class StarType
{
	WHITE,
	BLUE,
	YELLOW,
	ORANGE,
	RED,
	BROWN,
	BLACK //wow, black after white? racist scum
};

struct Star //a star point's data, whereby a star actor can expand upon it
{
	int64_t starID; //probably going to be the seed for the star actor too
	StarType type; //size determined later, with seed, since for now its just a colored point
	Vertex vertInfo;
};

struct Galaxy
{
	int64_t galaxyID; //the seed it was given
	GalaxyType type;
	std::vector<Star> stars;
};

//galaxy holder, not a galaxy actor holder, that's the actor manager's job.
//the galaxy actor should compose of a galaxy that was generated by this single class
class GalaxyGenerator
{
private:
	std::map<int64_t, Galaxy> _galaxies; //key is ID (seed given to "generate()")

public:
	GalaxyGenerator();
	~GalaxyGenerator();

	int setup();

	//seed determines the type
	int generate(int64_t seed);

	inline Galaxy *get(int64_t ID)
	{
		try
		{
			return &this->_galaxies.at(ID);
		}
		catch (std::exception err)
		{
			return nullptr;
		}
	}

protected:
	int genElliptical(int64_t ID);
	int genIrregular(int64_t ID);
	int genSpiral(int64_t ID);

	Star offset(Star &star, const glm::vec3 &offset);
	Star scale(Star &star, const glm::vec3 &scale);
	Star swirl(Star &star, const glm::vec3 &axis, float amount);
};


//TODO: wrap these in a namespace or something, and have a general "GalaxyGenerator" class to create and call, that lets you choose the type, also fix the stupid libnoise dependancy, try to implement varying star colors by grabbing a small texture with a gradient from light blue to red, and have it generate a linearly distributed float for uv coords for each vertex
//==========================================================
//========================Elliptical========================
//==========================================================
class Elliptical
{
private:
	float _size;

	float _densityMean;
	float _densityDeviation;

	float _deviationX;
	float _deviationY;
	float _deviationZ;

	std::vector<Vertex> _vertexData;
	std::vector<GLuint> _indexData;

public:
	Elliptical();
	~Elliptical();

	void generate(std::mt19937 module,
		float size,
		float densityMean = 0.0000025f, float densityDeviation = 0.000001f,
		float deviationX = 0.0000025f,
		float deviationY = 0.0000025f,
		float deviationZ = 0.0000025f);

	inline std::vector<Vertex> getVerts()
	{
		return this->_vertexData;
	}

	inline std::vector<GLuint> getIndices()
	{
		return this->_indexData;
	}

protected:


};

//==========================================================
//=========================Irregular========================
//==========================================================
class Irregular //sorta like me
{
private:
	float _countMean;
	float _countDeviation;

	float _metaSize;

	float _deviationX;
	float _deviationY;
	float _deviationZ;

	//irregulars consist of small ellipticals placed randomly, and they push back into these vectors to form one messy irregular
	std::vector<Vertex> _vertexData;
	std::vector<GLuint> _indexData;

public:
	Irregular();
	~Irregular();

	void generate(std::mt19937 module,
		float metaSize,
		float countMean = 0.0000025f,
		float countDeviation = 0.000001f,
		float deviationX = 0.0000025f,
		float deviationY = 0.0000025f,
		float deviationZ = 0.0000025f);

	inline std::vector<Vertex> getVerts()
	{
		return this->_vertexData;
	}

	inline std::vector<GLuint> getIndices()
	{
		return this->_indexData;
	}

protected:


};

//==========================================================
//==========================Spiral==========================
//==========================================================
class Spiral
{
private:


public:


protected:


};
#endif